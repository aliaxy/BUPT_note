# 树

### 查找(Searching)

|   查找   | 根据某个给顶关键字K，从集合R中找出关键字与K相同的记录 |
| :------: | :---------------------------------------------------- |
| 静态查找 | 集合中记录是固定的，没有插入和删除操作                |
| 动态查找 | 集合中记录是动态变化的，可能发生插入和删除            |

#### 静态查找：

**方法一：** 顺序查找(SequentialSearch)  ![](http://latex.codecogs.com/svg.latex?T(N) = O(N))

```c
int SequentialSearch (StaticTable *Tb, ElementType K)
{// Element[1]~Element[n] find K
    int i;
    Tb->Element[0] = K;	// insert the sentinel
    for(i = Tb->Length; Tb->Element[i] != K; i--) ;
    return i;	// succeed return i, or return 0
}
```

**方法二：** 二分查找(Binary Search)  ![](http://latex.codecogs.com/svg.latex?T(n) = O(log\ n))

```c
int BinarySearch(StaticTable *Tb, ElementType K)
{
    int left, right, mid, NotFound = -1;
    left = 1;				//initial left border
    right = Tb1->Lenght;	//initial right border
    while (left <= right) {
        mid =  left + ((right -left) >> 1);	//update the mid and prevent overflow
        if (K < Tb->Element[mid])
            right = mid - 1;	//update the right
        else if (K > Tb->Element[mid])
            left = mid + 1;		//update the left
        else
            return mid;	//Found
    }
    return NotFound;	// return -1
}
```

### 树(Tree)

#### 树的定义

树(Tree)是由 n(![](http://latex.codecogs.com/svg.latex?n \geqslant 0)) 个节点构成的有限集合。

当 n = 0 时，称为**空树**；

当 n > 0 时，称为**非空树**，非空树具备以下性质：

- 树中有一个称为**根(Root)**的特殊节点，用 r 表示
- 其余结点可分为 m (![](http://latex.codecogs.com/svg.latex?m \geqslant 0)) 个互不相交的有限集 ![](http://latex.codecogs.com/svg.latex?T_1,T_2,\dots,T_m)，其中每个集合本身又是一棵树，称为原来树的**子树(SubTree)**
  - 子树是不相交的
  - 除了根结点外，每个结点有且只有一个父节点
  - **一棵 N 个结点的树有 N - 1 条边**

#### 树的基本术语

|         名称         | 含义                                                         |
| :------------------: | :----------------------------------------------------------- |
|   结点的度(Dgree)    | 结点的**子树个数**                                           |
|        树的度        | 树的所有节点中**最大**的度数                                 |
|     叶结点(Leaf)     | **度为 0 **的结点                                            |
|    父节点(Parent)    | 有子树的结点是其子树的根节点的父节点                         |
|    子节点(Child)     | 若 A 结点是 B 结点的父结点，则称 B 结点是 A 结点的子节点     |
|  兄弟节点(Sibling)   | 具有同一父结点的各节点彼此是兄弟结点                         |
|    路径和路径长度    | 从结点![](http://latex.codecogs.com/svg.latex?n_1) 到 ![](http://latex.codecogs.com/svg.latex?n_k) 的路径为一个节点序列![](http://latex.codecogs.com/svg.latex?n_1,n_2,\dots,n_k) ，![](http://latex.codecogs.com/svg.latex?n_i) 是 ![](http://latex.codecogs.com/svg.latex?n_i+1)的父结点。 路径所包含边的条数为路径的长度。 |
|  祖先节点(Ancestor)  | 沿**树根**到某一结点路径上的所有结点都是这个结点的祖先结点   |
| 子孙节点(Descendant) | 某一结点的**子树中的所有结点**都是这个结点的子孙             |
|  结点的层次(Level)   | 规定**根节点在 1 层**，其他任一结点的层数是其父结点的层数加 1 |
|   树的深度(Depth)    | 树中所有结点中的**最大层次**是这棵树的深度                   |

#### 树的表示方式

**儿子-兄弟表示法**

### 二叉树(Binary Tree)

#### 二叉树的定义

**二叉树(Binary Tree)T **是一个有穷的结点集合。

- 这个集合可以为**空**。
- 若不为空，则它是由根节点和称为其**左子树![](http://latex.codecogs.com/svg.latex?T_L) ** 和**右子树![](http://latex.codecogs.com/svg.latex?T_R)**的两个不相交的二叉树组成。

**二叉树具体五种基本形态：**

空树，一个结点，只有左子树，只有右子树，左右子树都存在

**特殊二叉树：**

| 名称                                                       | 定义                                                         |
| :--------------------------------------------------------- | :----------------------------------------------------------- |
| 斜二叉树(Skewed Binary Tree)                               | 一边倒                                                       |
| 完美二叉树(Perfe Binary Tree) / 满二叉树(Full Binary Tree) | 设树有 k 层，则结点数为 ![](http://latex.codecogs.com/svg.latex? 2^k) |
| 完全二叉树（Complete Binary Tree）                         | 有 n 个结点的二叉树，对树中结点按从上至下、从左到右的顺序编号，编号为 i 结点![](http://latex.codecogs.com/svg.latex?(1 \leqslant i \leqslant n))与满二叉树中编号为 i 的结点在二叉树中位置相同 |

**二叉树的几个重要性质**

- 一个二叉树第 i 层的最大结点数为：![](http://latex.codecogs.com/svg.latex? 2^{i-1},i\geqslant 1)
- 深度为 k 的二叉树有最大节点总数为：![](http://latex.codecogs.com/svg.latex? 2^{k}-1,k \geqslant 1)
- 对任何非空二叉树 T ，若 ![](http://latex.codecogs.com/svg.latex? n_0) 表示叶结点的个数， ![](http://latex.codecogs.com/svg.latex? n_2)是度为 2 的非叶结点个数，那么两者关系满足 ![](http://latex.codecogs.com/svg.latex? n_0 = n_2 +1)(边数恒等证明)

![](http://latex.codecogs.com/svg.latex?  n_0 + n_1 + n_2 -1 = 0\times n_0 + 1 \times n_1 + 2 \times n_2)

**二叉树的抽象数据类型定义**

- 类型名称：二叉树
- 数据对象集：一个有穷的结点集合。若不为空则由根节点和其左右二叉子树构成。
- 操作集：BT ![](http://latex.codecogs.com/svg.latex? \in) BinTree，Item ![](http://latex.codecogs.com/svg.latex?\in) ElementType，重要操作有：
  - `Boolean IsEmpty(BinTree BT)`：判别 BT 是否为空
  - `void Traversal(BinTree BT)` ：遍历，按某顺序访问每个节点
  - `BinTree CreateBinTree()`：创建一个二叉树
- 常用的遍历方法：
  - `void PreOrderTraversal(BinTree BT)`：先序遍历——根、左子树、右子树
  - `void InOrderTraversal(BinTree BT)`：中序遍历——左子树、根、右子树
  - `void PostOrderTraversal`：后序遍历——左子树、右子树、根
  - `void LevelOrderTraversal(BinTree BT)`：层次遍历——从上到下、从左到右

#### 二叉树的存储结构

**顺序存储结构(完全二叉树 / 堆 ：按从上到下、从左到右的顺序存储)**

```c
typedef struct TreeNode *BinTree;
struct TreeNode {
    Element *Elements;
    int Size;
    int Capacity;
};
```

n 个结点的完全二叉树的结点父子关系：

* 非根节点 i 的父结点序号为 ![](http://latex.codecogs.com/svg.latex? i/2)
* 结点 i 的左孩子结点序号为 ![](http://latex.codecogs.com/svg.latex? 2i)（若 ![](http://latex.codecogs.com/svg.latex? 2i \leqslant n)则没有左孩子)
* 结点 i 的右孩子结点序号为![](http://latex.codecogs.com/svg.latex? 2i + 1) （若 ![](http://latex.codecogs.com/svg.latex? 2i + 1 \leqslant n)则没有右孩子)

**链表存储(一般二叉树)**

```c
typedef struct TreeNode *BinTree;
typedef BinTree Position;
struct TreeNode
{
    ElementType Data;
    BinTree Left;
    BinTree Right;
}
```

#### 二叉树的遍历

**递归遍历**

* 先序遍历

  ```c
  void PreOrderTraversal(BinTree BT)
  {
      if (BT)
      {
          printf("%d",BT->Data);			// visit root node
          PreOrderTraversal(BT->Left);	// traverse left tree
          PreOrderTraversal(BT->Right);	// traverse right tree
      }
  }
  ```

* 中序遍历

  ```c
  void InOrderTraversal(BinTree BT)
  {
      if (BT)
      {
          InOrderTraversal(BT->Left);		// traverse left tree
          printf("%d",BT->Data);			// visit root node
          InOrderTraversal(BT->Right);	// traverse right tree
      }
  }
  ```

* 后序遍历

  ```c
  void PostOrderTraversal(BinTree BT)
  {
      if (BT)
      {
          PostOrderTraversal(BT->Left);	// traverse left tree
          PostOrderTraversal(BT->Right);	// traverse right tree
          printf("%d",BT->Data);			// visit root node
      }
  }
  ```

* **先序、中序和后序遍历过程**：遍历过程中经过节点的**路线一样**，只是**访问各节点的时机不同**。

**非递归遍历(使用堆栈)**

* 中序遍历

  ```c
  void InOrderTraversal(BinTree BT)
  {
      BinTree T = BT;
      Stack S = CreatStack(MaxSize);	// create and initialize stack
      while (T || !IsEmpty(S))
      {
          while (T)
          {
              Push(S, T);		// push left node
              T = T->Left;	// traverse left tree
          }
          if (!IsEmpty(S))
          {
              T = Pop(S);					// pop node
              printf("%5d", T->Data);
              T = T->Right;				// traverse right tree
  		}
      }
  }
  ```

* 先序遍历

  ```c
  void PreOrderTraversal(BinTree BT)
  {
      BinTree T = BT;
      Stack S = CreatStack(MaxSize);	// create and initialize stack
      while (T || !IsEmpty(S))
      {
          while (T)
          {
              printf("%5d", T->Data);
              Push(S, T);		// push left node
              T = T->Left;	// traverse left tree
          }
          if (!IsEmpty(S))
          {
              T = Pop(S);					// pop node
              T = T->Right;				// traverse right tree
  		}
      }
  }
  ```

* 后序遍历

  ```c
  void PostOrderTraversal(BinTree BT)
  {
      BinTree T = BT;
      Stack S = CreatStack(MaxSize);	// create and initialize stack
      BinTree Temp = NULL;
      while (T || !IsEmpty(S))
      {
          while (T)
          {
              Push(S, T);		// push left node
              T = T->Left;	// traverse left tree
          }
          if (!IsEmpty(S))
          {
              T = Pop(S);					// pop node
              if (T->Right || T->Right == Temp)
              {
              	printf("%5d", T->Data);
                  Temp = T;
                  T = NULL;
              }
              else
              {
                  Push(S, T);
              	T = T->Right;				// traverse right tree
              }
          }
      }
  }
  ```

  
